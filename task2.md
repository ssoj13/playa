You can suggest on how to organize attributes for this task?


- Вот лаконичная схема атрибутов, чтобы клавиши/мышь работали предсказуемо и без дублирования логики:
  - Видимая часть (trim): play_start, play_end — в абсолютных кадрах родителя, всегда внутри [start, end]. Именно эти значения используют все операции трима (мышь, Alt-[, Alt-]).
    speed + source_start. Держите одну функцию-конвертер в Comp.
  - Вспомогательные геттеры: visible_start/visible_end (псевдо-геттер на play_*), bounds_start/bounds_end (псевдо-геттер на start/end).
  - Инварианты: start <= end, play_start <= play_end, оба в пределах [start, end]; при сдвиге слоя (move_child) сдвигать play_* тем же дельта и клампить в новые границы.
  - UI/горячие клавиши: [ / ] — работают с child_work_area_abs и move_child; Alt-[ / Alt-] — через trim_layers или set_child_play_* в абсолютных кадрах. Мышь и хоткеи должны вызывать один путь (у вас уже trim_layers).
  - События/кеш: любой сеттер, меняющий start/end/play_*, обязан чистить кеш и эмитить LayersChanged (у вас это в trim_layers/move_child; использовать их, а не ручные attrs.set).

  Если нужно добавить скорость/стретч:

  - Проигрывание: хранить speed на слое; расчёт видимого окна по времени — в конвертере abs -> local учитывать speed.
  - Ввод/вывод: все UI операции оперируют только абсолютными start/end/play_*; конверсия в локальные — централизованно в Comp.

  Этого достаточно, чтобы избежать «иногда не срабатывает»: все клавиши и мышь идут через одни и те же сеттеры/клампы, а инварианты держат валидное состояние.


› нет, то же самое: в первый раз на слое трим кнопками работает, а потом перестаёт. Это как-то может быть связано с недефолтными значениями Play_range? в первый-то раз работает корректно!