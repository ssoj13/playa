name: Build

on:
  push:
    tags:
      - 'v*'  # Only build on version tags (v0.1.26, etc.)
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: read  # No release creation needed, just build artifacts

jobs:
  # Check if the tag is NOT on main branch (we only want dev builds here)
  check-branch:
    runs-on: ubuntu-latest
    outputs:
      not-on-main: ${{ steps.check.outputs.not-on-main }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history to check branches

      - name: Check if tag is NOT on main branch
        id: check
        run: |
          # Check if the current tag is NOT reachable from main branch
          if git merge-base --is-ancestor HEAD origin/main 2>/dev/null; then
            echo "not-on-main=false" >> $GITHUB_OUTPUT
            echo "✗ Tag is on main branch - skipping build (will use Release workflow)"
          else
            echo "not-on-main=true" >> $GITHUB_OUTPUT
            echo "✓ Tag is NOT on main branch - proceeding with dev build"
          fi

  build-windows:
    runs-on: windows-latest
    needs: check-branch
    if: needs.check-branch.outputs.not-on-main == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@nightly

      - name: Cache cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "stable-v2"
          save-if: true
          key: "rust-deps-v2"
          cache-bin: false

      - name: Install cargo-packager
        uses: baptiste0928/cargo-install@v3
        with:
          crate: cargo-packager
          version: "0.11.7"
          cache-key: ${{ runner.os }}-v1

      - name: Build the application
        run: cargo xtask build --release

      - name: Package the application
        run: cargo packager --release

      - name: Find installer
        id: find_installer
        shell: pwsh
        run: |
          $installer = Get-ChildItem -Path "target/release" -Filter "playa_*-setup.*" | Select-Object -First 1
          if ($installer) {
            $relativePath = "target/release/$($installer.Name)"
            echo "path=$relativePath" >> $env:GITHUB_OUTPUT
            echo "Found installer: $($installer.FullName)"
            echo "Using relative path: $relativePath"
          } else {
            echo "Installer not found in target/release"
            exit 1
          }

      - name: Create portable ZIP
        shell: pwsh
        run: |
          # Get version from Cargo.toml
          $version = (Select-String -Path "Cargo.toml" -Pattern 'version = "([^"]+)"').Matches.Groups[1].Value

          # Create directory for portable version
          New-Item -ItemType Directory -Force -Path "portable" | Out-Null

          # Copy exe
          Copy-Item "target/release/playa.exe" -Destination "portable/"

          # Copy all dll files
          Get-ChildItem -Path "target/release" -Filter "*.dll" | Copy-Item -Destination "portable/"

          # Create zip
          $zipName = "playa-${version}-windows-portable.zip"
          Compress-Archive -Path "portable/*" -DestinationPath "target/release/$zipName" -Force

          echo "Created portable ZIP: $zipName"
          echo "Contents:"
          Get-ChildItem "portable" | Format-Table Name, Length

      - name: Upload Windows artifacts (installer + portable)
        uses: actions/upload-artifact@v5
        with:
          name: windows-artifacts
          path: |
            ${{ steps.find_installer.outputs.path }}
            target/release/playa-*-windows-portable.zip
          if-no-files-found: error
          retention-days: 7

  build-linux:
    runs-on: ubuntu-latest
    needs: check-branch
    if: needs.check-branch.outputs.not-on-main == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake libgtk-3-dev libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libspeechd-dev libxkbcommon-dev libssl-dev

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@nightly

      - name: Cache cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "stable-v2"
          save-if: true
          key: "rust-deps-v2"
          cache-bin: false

      - name: Install cargo-packager
        uses: baptiste0928/cargo-install@v3
        with:
          crate: cargo-packager
          version: "0.11.7"
          cache-key: ${{ runner.os }}-v1

      - name: Fetch dependencies
        run: cargo fetch

      - name: Build the application (with xtask)
        run: cargo xtask build --release

      - name: Package the application
        run: |
          export LD_LIBRARY_PATH="$(pwd)/target/release:$LD_LIBRARY_PATH"
          cargo packager --release

      - name: List bundle contents (if successful)
        run: |
          if [ -d "target/release/bundle" ]; then
            ls -R target/release/bundle/
          else
            echo "Bundle directory not found - build likely failed"
            exit 0
          fi

      - name: Find AppImage
        id: find_appimage
        run: |
          # Prefer top-level target/release output from cargo-packager
          appimage=$(find target/release -maxdepth 1 \( -name "*.AppImage" -o -name "*.appimage" \) 2>/dev/null | head -n 1)
          # Fallback to legacy bundle path if needed
          if [ -z "$appimage" ]; then
            appimage=$(find target/release/bundle/appimage -name "*.AppImage" 2>/dev/null | head -n 1)
          fi
          if [ -n "$appimage" ]; then
            echo "path=$appimage" >> $GITHUB_OUTPUT
            echo "Found AppImage: $appimage"
          else
            echo "No AppImage found"
          fi

      - name: Find DEB
        id: find_deb
        run: |
          # Prefer top-level target/release output from cargo-packager
          deb=$(find target/release -maxdepth 1 -name "*.deb" 2>/dev/null | head -n 1)
          # Fallback to legacy bundle path if needed
          if [ -z "$deb" ]; then
            deb=$(find target/release/bundle/deb -name "*.deb" 2>/dev/null | head -n 1)
          fi
          if [ -n "$deb" ]; then
            echo "path=$deb" >> $GITHUB_OUTPUT
            echo "Found DEB: $deb"
          else
            echo "No DEB found"
          fi

      - name: Upload Linux AppImage artifact
        if: steps.find_appimage.outputs.path != ''
        uses: actions/upload-artifact@v5
        with:
          name: linux-appimage
          path: ${{ steps.find_appimage.outputs.path }}
          retention-days: 7
          if-no-files-found: error

      - name: Upload Linux DEB artifact
        if: steps.find_deb.outputs.path != ''
        uses: actions/upload-artifact@v5
        with:
          name: linux-deb
          path: ${{ steps.find_deb.outputs.path }}
          retention-days: 7
          if-no-files-found: error
