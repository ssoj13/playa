Желательно унифицировать инициализацию элементов и их восстановление из сериализации, чтобы это делала одна и та же функция.
Не нужно совместимости, можно поменять формат сериализации если надо.
Изучи всё, проверь логику, нелогичные места, косяки, нереализованные места и TODO, и подобные вещи.

Нужно всё разделить на компоненты. Связывать всё будет PlayaApp и его UI.
Я хотел бы иметь несколько основных частей, полностью отделенных друг от друга, буквально в разных подкаталогах:

Окно Preferences - в подкаталог.
Окно Project - в подкаталог
Окно Timeline, Viewport - тоже в подкаталог.

- app.rs - приложение которое содержит все остальные части, логику старта и выхода, глобальный hotkeys handler, который смотрит над каким окном нажали кнопку и шлёт сообщение с нужным префиксом для этого окна (<hotkey.del:pressed>), CLI args и help.
- project.rs widget: contains clips and comps - в подкаталог
- viewport.rs widget: Generic viewport. Receives &Frame to display. Handles viewport controls, zoom, calculations, etc. - в подкаталог
- timeline.rs controller widget: After Effects-like timeline with clips and nested comp - в подкаталог
- ae.rs: ttribute editor widget: "Maya Attribute Editor": shows attributes of selected entity either in project or timeline window - в подкаталог
- noded.rs controller widget: Houdini-like node view. Node editor пока делать не надо, но вообще суть Clip и Comp именно в том что они - просто ноды разного типа с единым интерфейсом - в подкаталог
- node.rs: base node for noded.rs - в подкаталог с noded.rs
—-
- prefs dialog - в подкаталог. Prefs может хранить внутри себя hashmap c параметрами отображаемыми в окне, чтобы любая часть приложения могла их прочитать. Prefs Должны уметь сериализоваться в JSON. Прям все параметры диалога - в дерево JSON
- encoder dialog - в подкаталог encoding, чтобы он был подмодулем и связывался с внешним миром сообщениями. Чтобы его парой строк вообще можно было отделить от основного приложения. Ну может какой-то быстрый интерфейс, т.к. нам нужно передавать кадры или рефы на них на кодирование.
- hotkeys dialog - в подкаталог 


- Все части функционально отделены друг от друга, и имеют простые стандартные интерфейсы.
Общение частей происходит либо через каналы (crossbar?) либо через шину сообщений, какие в Rust есть варианты?
Т.е. нажатие кнопок, перемотка таймслайдера, процесс проигрывания - всё контрольные элементы просто посылают сообщения, а соответствующие функции "слушают" их и что-то делают.
Например drag'n'drop на окно проекта, кнопка Add Clip, аргумент -f - все просто испускают сигнал "добавить clip с аргументом для клипа".
Все кнопки, например Play/pause, Start, End - тоже сигналы. Клавиши JKL, B/N/Ctrl-B - все кнопки тоже испускают сигналы, а keyboard handler слушает.

- У каждого окна свой handler hotkeys: он слушает сообщения, и если получает, скажем "<hotkeys.b: pressed>" - то "забирает" его себе и вызывает функцию которая висит на b.
Эти сообщения посылает глобальный хэндлер нажатий на кнопки (в App), который определяет какому элементу отправить сообщение 



- Базовые структуры (Entities) должны работать без GUI: Project, Clip, Comp, Encoder, Node processing engine (Node struct with all required traits for parent-child relationship and graph processing)
(В теории потом можно будет прицепить питоновский API и процессить видео в батче без GUI.)

Entities должны поддерживать трейты для GUI типа
  - ::project_ui	: widget элемента для окна проекта: имя клипа или компа и какие-то метаданные: разрешение, кол-во кадров
  - ::timeline_ui	: widget элемента для таймлайна, обычно бар
  - ::ae_ui			: widget со всеми атрибутами элемента. При изменении значений, должны обновляться атрибуты соответствющего активного (selected) Clip/Comp. Аналог Maya Attribute Editor
То есть например Clip или Comp будут иметь одно представление для окна проекта, другое - для таймлайна, третье - для AE.
Если это будут функции рисования (как в egui это работает?) - ну и хорошо.


Entities предоставляют handlers, слоты или API/Interface для контроллеров:
  - Сигнал "добавить клип" просто вызывает Project.add_media(&metadata)
  - Сигнал "добавить комп" просто создаёт Comp с настройками по умолчанию (настройки проекта по умолчанию - отдельная секция конфига Project)
  - Процесс Drag'n'Drop сначала берёт клип или комп под мышью
    - dnd_start(&Media) запоминает что тащат
    - dnd_drag() - рисует временную визуализацию бара клипа или компа на месте мыши и снэпится к краям клипов которые предоставляет Comp
    - dnd_drop() опять же вызывает сигнал "project.add_media" -> принимается Comp.add_media(move |Media| = ....)
    - и так далее
  - Перетаскивание слайдера на таймлайне просто посылает сообщение "comp.set_frame", и оно диспатчится -> Comp.set_frame(num)
Таким образом мы можем применять эти функции и в неблокирующемся GUI и в API.


---
Теперь по интерфейсу:
  - Мы можем использовать https://crates.io/crates/hello_egui, в частности egui_dnd и egui_taffy, egui_dock - для стайлинга, drag'n'drop и для сплитов. Изучи это всё, мне нужен хороший интерфейс, а то мы проблему с прыгающим таймлайном так и не решили.



1. Нет, нам нужно удалить Layer. Он логически нигде не нужен, просто засоряет код ненужностями.
2. Кроме того я только что переосмыслил концепцию:
  - Comp будет и контейнером и слоем, который может содержать другие Comp.
  - Загрузка кадров с диска станет особым режимом:
    - Добавляем в Comp флаг "mode": с двумя значениями: mode_layer и mode_file.
    - Каждая Comp должна содержать следующие атрибуты:
      - position, rotate, scale, pivot, (эти Vec3 значения формируют внутреннюю transformation matrix4), transparency, layer_mode (normal, screen, add, substract, mult, divide), speed. границы комп должны корректно рассчитываться с учетом speed и всех смещений и тримов.
      - атрибут mode: enum со значениями mode_layer и mode_file
      - для режима file: file_mask, file_start, file_end. По умолчанию пустые (и если пустые или start==end то загрузка не идёт, выдаётся Placeholder)
      - атрибут parent: uuid, атрибут children: Vec<uuid> - это система parent-child relationship. Children - это под-слои этой Comp, другие Comp.
      - атрибут Comp::hash: содержит хэш композиции. В режиме layer это аккумулированные хэши всех подслоёв, в режиме file это хэш file_mask и file_start/end
      - добавляем атрибуты play_start, play_end. Для текущего компа они определяют его рабочую зону, для всех вложенных - буквально начало и конец. Т.е. вложенные Comps в Comp рисуются используя их внутренний play_start/end
    - Когда мы переключаем mode на mode_seq, то композ вместо сборки кадров и их композа, начинает читать файлы с диска. Если файлы не удаётся прочитать - выдаётся placeholder. Переносим функциональность загрузки и детекции image sequence в Comp.
    - то что выдаёт compose() кэшируется в Comp::cache[frame]. Кэш обновляется если у этого текущий хэш не совпадает с сохранённым в атрибутах - тогда обновляем хэш, считаем кадр compose(), записываем hash и Frame в атрибуты и данные.
    - Добавляем в Comp children: Vec<uuid> - это будут uuid children Comps
    - При передвижении (drag) клипов по таймлайну учитываем play_start и play_end. Клипы могут уехжать за левую границу timeline, там где их названия - просто названия рисуются поверх.

нужен какой-то универсальный алгоритм для рассчёта кадра для вложенных и ретаймленных comps. Это должна делать одна функция и для всего сразу.
Также нужен мэппинг на окно timeline: time ruler и time slider, а также все вложенные Comps должны "жить" в одном пространстве, в одном времени. В которое пользователь может зумиться и панорамировать в окне. Всё как с Viewport, но только в горизонтальном направлении онли и мы зумим кадры.
По сути нужна функция мэппинга из timeline_widget space в frame space - в внутреннее время Comp. Тут подскажи как лучше.
Всё должно быть унифицировано.


посмотри всё ли верно опмсано, проверь проект.
Есть ли ошибки, логические или фактические? Слабые места?
Учти что мне нужно чтобы этот плеер работал с гигантскими файлами, избегай копирования памяти.
С самого начало всё нужно делать с учётом интеграции egui_taffy, egui_dock, egui_dnd, нужные интерфейсы переработать, сохраняя рабочую логику.
Составь краткий но подробный анализ и пошаговый оптимальный план действий
Don't try to guess, you have to be SURE.
No compatibility needed, this is WiP
Use internet, MCP, sub-agents and work in parallel



Переработай image loader. Он должен использоваться во Frame, но саму загрузку сделай через struct Loader, где будут функции для чтения заголовка файла и его содержимого.
При этом Loader::header(filename) -> HashMap of metadata и Loader::load(filename) -> Frame вызывают разные функции в зависимости от того используется ли openexr или нет. Если нет - всё грузим через crate image который использует exrs.
Если без openexr - то только image.

Интерфейс - Frame.file_header() и .file_load().